/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/rdu/Workspace/librav/src/libraries/uavcan/libuavcan/test/dsdl_test/root_ns_a/UnionTest.uavcan
 */

#ifndef ROOT_NS_A_UNIONTEST_HPP_INCLUDED
#define ROOT_NS_A_UNIONTEST_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

#include <root_ns_a/Empty.hpp>
#include <root_ns_a/NestedInUnion.hpp>

/******************************* Source text **********************************
# Max bit len 16 bits
@union          # 3 bits
Empty         z
uint5         a
uint5         b # Conflicting with a
uint13        c
bool[<=9]     d # 4 bit length field + 9 bit payload
NestedInUnion e
******************************************************************************/

/********************* DSDL signature source definition ***********************
root_ns_a.UnionTest
@union
root_ns_a.Empty z
saturated uint5 a
saturated uint5 b
saturated uint13 c
saturated bool[<=9] d
root_ns_a.NestedInUnion e
******************************************************************************/

#undef z
#undef a
#undef b
#undef c
#undef d
#undef e

namespace root_ns_a
{

template <int _tmpl>
struct UAVCAN_EXPORT UnionTest_
{
    typedef const UnionTest_<_tmpl>& ParameterType;
    typedef UnionTest_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
    };

    struct FieldTypes
    {
        typedef ::root_ns_a::Empty z;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > a;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > b;
        typedef ::uavcan::IntegerSpec< 13, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > c;
        typedef ::uavcan::Array< ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeDynamic, 9 > d;
        typedef ::root_ns_a::NestedInUnion e;
    };

    struct Tag
    {
        enum Type
        {
            z,
            a,
            b,
            c,
            d,
            e
        };
    };

    typedef ::uavcan::IntegerSpec< ::uavcan::IntegerBitLen< 6 >::Result,
                                   ::uavcan::SignednessUnsigned, ::uavcan::CastModeTruncate > TagType;

    enum
    {
        MinBitLen = TagType::BitLen +
            ::uavcan::EnumMin<FieldTypes::z::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::a::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::b::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::c::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::d::MinBitLen,
                FieldTypes::e::MinBitLen >::Result>::Result>::Result>::Result>::Result
    };

    enum
    {
        MaxBitLen = TagType::BitLen +
            ::uavcan::EnumMax<FieldTypes::z::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::a::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::b::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::c::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::d::MaxBitLen,
                FieldTypes::e::MaxBitLen >::Result>::Result>::Result>::Result>::Result
    };

    // Constants

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::z >::Type z;
    typename ::uavcan::StorageType< typename FieldTypes::a >::Type a;
    typename ::uavcan::StorageType< typename FieldTypes::b >::Type b;
    typename ::uavcan::StorageType< typename FieldTypes::c >::Type c;
    typename ::uavcan::StorageType< typename FieldTypes::d >::Type d;
    typename ::uavcan::StorageType< typename FieldTypes::e >::Type e;

private:
    typename ::uavcan::StorageType< TagType >::Type _tag_;  // The name is mangled to avoid clashing with fields

    template <typename Tag::Type T>
    struct TagToType;

public:

    UnionTest_()
        : z()
        , a()
        , b()
        , c()
        , d()
        , e()
        , _tag_()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<16 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /**
     * Explicit access to the tag.
     * It is safer to use is()/as()/to() instead.
     */
    typename Tag::Type getTag() const { return typename Tag::Type(_tag_); }
    void setTag(typename Tag::Type x) { _tag_ = typename ::uavcan::StorageType< TagType >::Type(x); }

    /**
     * Whether the union is set to the given type.
     * Access by tag; this will work even if there are non-unique types within the union.
     */
    bool is(typename Tag::Type x) const { return typename Tag::Type(_tag_) == x; }

    /**
     * If the union is currently set to the type T, returns pointer to the appropriate field.
     * If the union is set to another type, returns null pointer.
     */
    template <typename Tag::Type T>
    inline const typename TagToType<T>::StorageType* as() const;

    /**
     * Switches the union to the given type and returns a mutable reference to the appropriate field.
     * If the previous type was different, a default constructor will be called first.
     */
    template <typename Tag::Type T>
    inline typename TagToType<T>::StorageType& to();

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    // This type has no default data type ID

    static const char* getDataTypeFullName()
    {
        return "root_ns_a.UnionTest";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool UnionTest_<_tmpl>::operator==(ParameterType rhs) const
{
    if (_tag_ != rhs._tag_)
    {
        return false;
    }
    if (_tag_ == 0)
    {
        return z == rhs.z;
    }
    if (_tag_ == 1)
    {
        return a == rhs.a;
    }
    if (_tag_ == 2)
    {
        return b == rhs.b;
    }
    if (_tag_ == 3)
    {
        return c == rhs.c;
    }
    if (_tag_ == 4)
    {
        return d == rhs.d;
    }
    if (_tag_ == 5)
    {
        return e == rhs.e;
    }
    UAVCAN_ASSERT(0);   // Invalid tag
    return false;
}

template <int _tmpl>
bool UnionTest_<_tmpl>::isClose(ParameterType rhs) const
{
    if (_tag_ != rhs._tag_)
    {
        return false;
    }
    if (_tag_ == 0)
    {
        return ::uavcan::areClose(z, rhs.z);
    }
    if (_tag_ == 1)
    {
        return ::uavcan::areClose(a, rhs.a);
    }
    if (_tag_ == 2)
    {
        return ::uavcan::areClose(b, rhs.b);
    }
    if (_tag_ == 3)
    {
        return ::uavcan::areClose(c, rhs.c);
    }
    if (_tag_ == 4)
    {
        return ::uavcan::areClose(d, rhs.d);
    }
    if (_tag_ == 5)
    {
        return ::uavcan::areClose(e, rhs.e);
    }
    UAVCAN_ASSERT(0);   // Invalid tag
    return false;
}

template <int _tmpl>
int UnionTest_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    const int res = TagType::encode(self._tag_, codec, ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    if (self._tag_ == 0)
    {
        return FieldTypes::z::encode(self.z, codec, tao_mode);
    }
    if (self._tag_ == 1)
    {
        return FieldTypes::a::encode(self.a, codec, tao_mode);
    }
    if (self._tag_ == 2)
    {
        return FieldTypes::b::encode(self.b, codec, tao_mode);
    }
    if (self._tag_ == 3)
    {
        return FieldTypes::c::encode(self.c, codec, tao_mode);
    }
    if (self._tag_ == 4)
    {
        return FieldTypes::d::encode(self.d, codec, tao_mode);
    }
    if (self._tag_ == 5)
    {
        return FieldTypes::e::encode(self.e, codec, tao_mode);
    }
    return -1;          // Invalid tag value
}

template <int _tmpl>
int UnionTest_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    const int res = TagType::decode(self._tag_, codec, ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    if (self._tag_ == 0)
    {
        return FieldTypes::z::decode(self.z, codec, tao_mode);
    }
    if (self._tag_ == 1)
    {
        return FieldTypes::a::decode(self.a, codec, tao_mode);
    }
    if (self._tag_ == 2)
    {
        return FieldTypes::b::decode(self.b, codec, tao_mode);
    }
    if (self._tag_ == 3)
    {
        return FieldTypes::c::decode(self.c, codec, tao_mode);
    }
    if (self._tag_ == 4)
    {
        return FieldTypes::d::decode(self.d, codec, tao_mode);
    }
    if (self._tag_ == 5)
    {
        return FieldTypes::e::decode(self.e, codec, tao_mode);
    }
    return -1;          // Invalid tag value
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::z>
{
    typedef typename UnionTest_<0>::FieldTypes::z Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::z >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::z >() const
{
    return is(UnionTest_<0>::Tag::z) ? &z : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::z >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::z >()
{
    if (_tag_ != 0)
    {
        _tag_ = 0;
        z = typename TagToType< UnionTest_<0>::Tag::z >::StorageType();
    }
    return z;
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::a>
{
    typedef typename UnionTest_<0>::FieldTypes::a Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::a >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::a >() const
{
    return is(UnionTest_<0>::Tag::a) ? &a : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::a >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::a >()
{
    if (_tag_ != 1)
    {
        _tag_ = 1;
        a = typename TagToType< UnionTest_<0>::Tag::a >::StorageType();
    }
    return a;
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::b>
{
    typedef typename UnionTest_<0>::FieldTypes::b Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::b >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::b >() const
{
    return is(UnionTest_<0>::Tag::b) ? &b : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::b >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::b >()
{
    if (_tag_ != 2)
    {
        _tag_ = 2;
        b = typename TagToType< UnionTest_<0>::Tag::b >::StorageType();
    }
    return b;
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::c>
{
    typedef typename UnionTest_<0>::FieldTypes::c Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::c >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::c >() const
{
    return is(UnionTest_<0>::Tag::c) ? &c : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::c >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::c >()
{
    if (_tag_ != 3)
    {
        _tag_ = 3;
        c = typename TagToType< UnionTest_<0>::Tag::c >::StorageType();
    }
    return c;
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::d>
{
    typedef typename UnionTest_<0>::FieldTypes::d Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::d >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::d >() const
{
    return is(UnionTest_<0>::Tag::d) ? &d : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::d >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::d >()
{
    if (_tag_ != 4)
    {
        _tag_ = 4;
        d = typename TagToType< UnionTest_<0>::Tag::d >::StorageType();
    }
    return d;
}

template <>
template <>
struct UnionTest_<0>::TagToType<UnionTest_<0>::Tag::e>
{
    typedef typename UnionTest_<0>::FieldTypes::e Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::e >::StorageType*
UnionTest_<0>::as< UnionTest_<0>::Tag::e >() const
{
    return is(UnionTest_<0>::Tag::e) ? &e : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest_<0>::TagToType< UnionTest_<0>::Tag::e >::StorageType&
UnionTest_<0>::to< UnionTest_<0>::Tag::e >()
{
    if (_tag_ != 5)
    {
        _tag_ = 5;
        e = typename TagToType< UnionTest_<0>::Tag::e >::StorageType();
    }
    return e;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature UnionTest_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0xA7F15977B65CEFCAULL);

    FieldTypes::z::extendDataTypeSignature(signature);
    FieldTypes::a::extendDataTypeSignature(signature);
    FieldTypes::b::extendDataTypeSignature(signature);
    FieldTypes::c::extendDataTypeSignature(signature);
    FieldTypes::d::extendDataTypeSignature(signature);
    FieldTypes::e::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

/*
 * Final typedef
 */
typedef UnionTest_<0> UnionTest;

// No default registration

} // Namespace root_ns_a

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::root_ns_a::UnionTest >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::root_ns_a::UnionTest::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::root_ns_a::UnionTest >::stream(Stream& s, ::root_ns_a::UnionTest::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    if (static_cast<int>(obj.getTag()) == 0)
    {
        s << "z: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::z >::stream(s, obj.z, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 1)
    {
        s << "a: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::a >::stream(s, obj.a, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 2)
    {
        s << "b: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::b >::stream(s, obj.b, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 3)
    {
        s << "c: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::c >::stream(s, obj.c, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 4)
    {
        s << "d: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::d >::stream(s, obj.d, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 5)
    {
        s << "e: ";
        YamlStreamer< ::root_ns_a::UnionTest::FieldTypes::e >::stream(s, obj.e, level + 1);
    }
}

}

namespace root_ns_a
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::root_ns_a::UnionTest::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::root_ns_a::UnionTest >::stream(s, obj, 0);
    return s;
}

} // Namespace root_ns_a

#endif // ROOT_NS_A_UNIONTEST_HPP_INCLUDED